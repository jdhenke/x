(define (not x)
  (if x #f #t))

(define (reverse l)
  (let loop ((l l) (t (list)))
    (if (null? l)
      t
      (loop (cdr l) (cons (car l) t)))))

(define (append . args)
  (let arglp ((args args)
               (out (list)))
    (if (null? args)
      (reverse out)
      (arglp (cdr args)
             (let itemlp ((l (car args))
                          (out out))
               (if (null? l)
                 out
                 (itemlp (cdr l) (cons (car l) out))))))))

(define (curry f . largs)
  (lambda rargs
    (apply f (append largs rargs))))

(define (caar x) (car (car x)))
(define (cadr x) (car (cdr x)))
(define (cddr x) (cdr (cdr x)))
(define (caadr x) (car (car (cdr x))))
(define (caddr x) (car (cdr (cdr x))))
(define (cdadr x) (cdr (car (cdr x))))
(define (cdddr x) (cdr (cdr (cdr x))))
(define (cadar x) (car (cdr (car x))))
(define (cadddr x) (car (cdr (cdr (cdr x)))))

(define (find f l)
  (let loop ((l l))
    (if (null? l)
      #f
      (if (f (car l))
        (car l)
        (loop (cdr l))))))

(define (map f l)
  (let loop ((l l)
             (out (list)))
    (if (null? l)
      (reverse out)
      (loop (cdr l) (cons (f (car l)) out)))))

(define eof (lambda () #f)) ; sepxr will never be a function

(define _peek-c #f)

(define (peek-c)
  (if (equal? _peek-c #f)
    (set! _peek-c
      (let ((c (sys/read 0 1)))
        (if (equal? c "")
          eof
          c))))
  _peek-c)

(define (read-c)
  (let ((out (peek-c)))
    (set! _peek-c #f)
    out))
  
(define (eof? c) (equal? c eof))

(define (print x)
  (cond
    ((string? x) (sys/write 1 x (string-length x)))
    ((symbol? x)    (print (string x)))
    ((boolean? x)   (print (if x "#t" "#f")))
    ((number? x)    (print (number->string x)))
    ((function? x)  (print ("Î»")))
    ((list? x)
     (let ()
       (print "(")
       (let loop ((l x))
         (if (null? l)
           (print ")")
           (let ()
             (print (car l))
             (if (not (null? (cdr l)))
               (print " "))
             (loop (cdr l)))))))))

(define (println x)
  (print x)
  (print "\n"))

(define (newline)
  (print "\n"))

(define display print)

(define (error . args)
  (println "ERROR")
  (map println args)
  (sys/exit 1))

(define (enumerate f l)
  (let loop ((i 0)
             (l l)
             (out (list)))
    (if (null? l)
      (reverse out)
      (loop (+ i 1) (cdr l) (cons (f i (car l)) out)))))

(define (>= a b)
  (< b (+ a 1)))

(define (<= a b) (>= b a))

(define (first l) (car l))
(define (second l) (cadr l))
(define (third l) (caddr l))
(define (last l) (first (reverse l)))

(define (zip . ls)
  (let loop ((ls ls)
             (out (list)))
    (if (find null? ls)
      (reverse out)
      (loop (map cdr ls) (cons (map car ls) out)))))

(define (filter f l)
  (let loop ((l l)
             (out (list)))
    (if (null? l)
      (reverse out)
      (loop (cdr l)
            (if (f (car l))
              (cons (car l) out)
              out)))))

(define for-each map)

(define (> a b) (< b a))

(define = equal?)

(define (assoc k l)
  (find (lambda (r) (equal? (car r) k)) l))

(define (sublist l i j)
  (let loop ((l l)
        (i i)
        (j j)
        (out (list)))
    (cond ((> i 0) (loop (cdr l) (- i 1) (- j 1) out))
          ((> j 0) (loop (cdr l) 0 (- j 1) (cons (car l) out)))
          (#t (reverse out)))))

(define pretty-print print)

(define runtime "x")

(define n-to-s
  (list (list 0 "0")
        (list 1 "1")
        (list 2 "2")
        (list 3 "3")
        (list 4 "4")
        (list 5 "5")
        (list 6 "6")
        (list 7 "7")
        (list 8 "8")
        (list 9 "9")))

(define s-to-n
  (list (list "0" 0)
        (list "1" 1)
        (list "2" 2)
        (list "3" 3)
        (list "4" 4)
        (list "5" 5)
        (list "6" 6)
        (list "7" 7)
        (list "8" 8)
        (list "9" 9)))

(define (number->string x)
  (define out (list))
  (if (< x 0)
    (let () (set! x (- 0 x)) (set! out (cons "-" out))))
  (let loop ((x x) (out out))
    (if (> x 9)
      (let ((r (modulo x 10)))
        (loop (/ x 10) (cons (cadr (assoc r n-to-s)) out)))
      (apply string-append (cons (cadr (assoc x n-to-s)) out)))))

(define (string->number s)
  (let loop ((cs (string-list s)) (out 0))
    (if (null? cs)
      out
      (loop (cdr cs) (+ (* out 10) (cadr (assoc (car cs) s-to-n)))))))

(define (string-number? s)
  (and
    (> (string-length s) 0)
    (let loop ((l (string-list s)))
      (if (null? l)
        #t
        (if (assoc (car l) s-to-n)
          (loop (cdr l))
          #f)))))

(define (make-env runtime)
  (list
    (list
      (list "+" +)
      (list "equal?" equal?)
      (list "string-append" string-append)
      (list "list" list)
      (list "+" +)
      (list "-" -)
      (list "*" *)
      (list "/" /)
      (list "modulo" modulo)
      (list "<" <)
      (list ">" >)
      (list ">=" >=)
      (list "<=" <=)
      (list "=" =)
      (list "append" append)
      (list "apply" apply)
      (list "assoc" assoc)
      (list "boolean?" boolean?)
      (list "caadr" caadr)
      (list "caar" caar)
      (list "cadar" cadar)
      (list "cadddr" cadddr)
      (list "caddr" caddr)
      (list "cadr" cadr)
      (list "car" car)
      (list "cdr" cdr)
      (list "cdadr" cdadr)
      (list "cddr" cddr)
      (list "cdddr" cdddr)
      (list "cons" cons)
      (list "curry" curry)
      (list "display" display)
      (list "filter" filter)
      (list "enumerate" enumerate)
      (list "eof?" eof?)
      (list "equal?" equal?)
      (list "error" error)
      (list "find" find)
      (list "first" first)
      (list "for-each" for-each)
      (list "length" length)
      (list "last" last)
      (list "list" list)
      (list "list?" list?)
      (list "map" map)
      (list "newline" newline)
      (list "not" not)
      (list "null?" null?)
      (list "number->string" number->string)
      (list "number?" number?)
      (list "pair?" pair?)
      (list "peek-c" peek-c)
      (list "pretty-print" pretty-print)
      (list "print" print)
      (list "println" println)
      (list "read-c" read-c)
      (list "reverse" reverse)
      (list "second" second)
      (list "set-car!" set-car!)
      (list "set-cdr!" set-cdr!)
      (list "string" string)
      (list "string->number" string->number)
      (list "string-append" string-append)
      (list "string-length" string-length)
      (list "string-number?" string-number?)
      (list "string?" string?)
      (list "sublist" sublist)
      (list "symbol" symbol)
      (list "symbol?" symbol?)
      (list "sys/exit" sys/exit)
      (list "sys/read" sys/read)
      (list "third" third)
      (list "zip" zip)
    )
    #f))
