;;; EVAL

(define (eval sexpr env k)
  (cond ((list? sexpr)    (eval-verb sexpr env k))
        ((boolean? sexpr) (k sexpr))
        ((number? sexpr)  (k sexpr))
        ((string? sexpr)  (k sexpr))
        ((symbol? sexpr)  (error "eval: unexpected symbol:" sexpr))
        (#t (error "unknown sexpr type" sexpr))))

(define (eval-verb sexpr env k)
  (cond ((null? sexpr) sexpr)
        ((or (equal? (car sexpr) '_ll)
             (equal? (car sexpr) '_lg))          (k (lookup sexpr env)))
        ((equal? (car sexpr) (symbol "define"))  (eval-define sexpr env k))
        ((equal? (car sexpr) (symbol "set!"))    (eval-set! sexpr env k))
        ((equal? (car sexpr) (symbol "lambda"))  (define-lambda sexpr env k))
        ((equal? (car sexpr) (symbol "apply"))   (eval-apply sexpr env k))
        ((equal? (car sexpr) (symbol "let"))     (eval-let sexpr env k))
        ((equal? (car sexpr) (symbol "let*"))    (eval-let sexpr env k))
        ((equal? (car sexpr) (symbol "if"))      (eval-if sexpr env k))
        ((equal? (car sexpr) (symbol "cond"))    (eval-cond sexpr env k))
        ((equal? (car sexpr) (symbol "or"))      (eval-or sexpr env k))
        ((equal? (car sexpr) (symbol "and"))     (eval-and sexpr env k))
        ((equal? (car sexpr) (symbol "quote"))   (eval-quote sexpr env k))
        ((equal? (car sexpr) (symbol "call/cc")) (eval-call/cc sexpr env k))
        (#t                                      (call-func sexpr env k))))

(define (eval-define sexpr env k)
  (let ((s (car (second sexpr))))
    (if (or (equal? s '_ll) (equal? s '_lg))
      (define-var sexpr env k)
      (define-func sexpr env k))))

(define (define-var sexpr env k)
  (let ((c (second sexpr)))
    (if (and (equal? (first c) '_ll) (= (second c) 0))
      (eval-set! sexpr env k)
      (let ((name (if (equal? (first c) '_ll) (fourth c) (second c))))
        (eval (third sexpr) env
              (lambda (val)
                (set-car! env (append (car env) (list (list name val) )))
                (k val)))))))

(define (define-func sexpr env k)
  (let ((name (caadr sexpr))
        (named (cdadr sexpr))
        (rest #f)
        (body (cddr sexpr)))
    (if (and (> (length named) 1) (equal? (second (reverse named)) (symbol ".")))
      (let ()
        (set! rest (first (reverse named)))
        (set! named (reverse (cddr (reverse named))))))
    (define f (define-body env #f named rest body))
    (set-car! env (append (car env) (list (list name f))))
    (k f)))

(define (eval-set! sexpr env k)
  (let ((c (cadr sexpr)))
    (eval (caddr sexpr) env
          (lambda (val)
            (let loop ((env env) (depth 0))
              (if (= depth (cadr c))
                (let ((p (list-ref (car env) (caddr c))))
                  (set-cdr! p (list val))
                  (k val))
                (loop (cadr env) (+ depth 1))))))))

(define (define-lambda sexpr env k)
  (let* ((args (second sexpr))
         (named (if (list? args) args (list)))
         (rest (if (list? args) #f args))
         (body (cddr sexpr)))
    (if (and (> (length named) 1) (equal? (second (reverse named)) (symbol ".")))
      (let ()
        (set! rest (first (reverse named)))
        (set! named (reverse (cddr (reverse named))))))
    (k (define-body env #f named rest body))))

(define (eval-apply sexpr env k)
  (eval (cadr sexpr) env
        (lambda (f)
          (eval (caddr sexpr) env
                (lambda (args)
                  (apply f (cons k args)))))))

(define (eval-let sexpr env k)
  (let* ((let-name (if (list? (second sexpr)) #f (second sexpr)))
         (arg-clause (find list? sexpr))
         (argnames (map (lambda (p) (car p)) arg-clause))
         (body (if let-name (cdddr sexpr) (cddr sexpr))))
    (let ((f (define-body env let-name argnames #f body)))
      (let arg-loop ((exprs arg-clause)
                     (vals (list)))
        (if (null? exprs)
          (apply f (cons k (reverse vals)))
          (let* ((arg-env (list (zip argnames (reverse vals)) env)))
            (eval (cadar exprs) arg-env
                  (lambda (val)
                    (arg-loop (cdr exprs) (cons val vals))))))))))

(define (define-body env self named rest body)
  (let ((env (list (list) env)))
    (define (f k . args)
      (let ((env (list (bind-args args named rest) env)))
        (define (body-loop-cps body)
          (cond ((null? body) (k #f))
                ((null? (cdr body)) (eval (car body) env k))
                (#t (eval (car body) env (lambda (v) (body-loop-cps (cdr body)))))))
        (body-loop-cps body)))
    (if self (set-car! env (list (list self f))))
    f))

(define (bind-args args named rest)
  (append
    (zip named args)
    (if rest
      (list (list rest (sublist args (length named) (length args))))
      (list))))

(define (eval-if sexpr env k)
  (let* ((p (cadr sexpr))
         (t (caddr sexpr))
         (f (if (> (length sexpr) 3) (cadddr sexpr) #f)))
    (eval p env
          (lambda (pv)
            (eval (if pv t f) env k)))))

(define (eval-cond sexpr env k)
  (let loop ((conds (cdr sexpr)))
    (if (null? conds)
      (k #f)
      (eval (caar conds) env
            (lambda (cv)
              (if cv
                (eval (cadar conds) env k)
                (loop (cdr conds))))))))

(define (eval-or sexpr env k)
  (let loop ((clauses (cdr sexpr)))
    (cond ((null? clauses) (k #f))
          (#t (eval (car clauses) env
                    (lambda (cv)
                      (if cv
                        (k #t)
                        (loop (cdr clauses)))))))))

(define (eval-and sexpr env k)
  (let loop ((clauses (cdr sexpr)))
    (cond ((null? clauses) (k #t))
          (#t (eval (car clauses) env
                    (lambda (cv)
                      (if cv
                        (loop (cdr clauses))
                        (k #f))))))))

(define (call-func sexpr env k)
  (eval (car sexpr) env
        (lambda (f)
          (define args (list))
          (let loop ((exprs (cdr sexpr)) (args (list)))
            (if (null? exprs)
              (apply f (cons k (reverse args)))
              (eval (car exprs) env
                    (lambda (argv)
                      (loop (cdr exprs) (cons argv args)))))))))

(define (eval-call/cc sexpr env k)
  (eval (cadr sexpr) env
        (lambda (f)
          (f k (lambda (k2 val) (k val))))))

(define (eval-quote sexpr env k)
  (k (cadr sexpr)))

(define (lookup c env)
  (if (equal? (car c) '_ll)
    (let ((depth (cadr c))
          (offset (caddr c))
          (orig env))
      (let loop ((d 0) (env env))
        (if (= d depth)
          (let ()
            (if (>= offset (length (car env)))
              (let ()
                (enumerate (lambda (i p) (println (list i p)))(car env))
                (println orig)
                (error "xi: offset mismatch:" c)))
          (let ((p (list-ref (car env) offset)))
            (if (not (equal? (fourth c) (first p)))
              (let ()
                (enumerate (lambda (i p) (println (list i p)))(car env))
                (error "xi: lookup mismatch:" c p)))
            (cadr p)))
          (loop (+ d 1) (cadr env)))))
    (let ((name (cadr c)))
      (let ((defs (car env))
            (parent (cadr env)))
        (let ((d (assq name defs)))
          (if d
            (cadr d)
            (if parent (lookup c parent) (error "undefined" runtime name))))))))

;;; REPL

;;; FIXME! ; why can't I redefined runtime??
(set! runtime (string-append runtime "i"))

(define (native-to-cps n f)
  (lambda (k . args)
    (k (apply f args))))

(define (make-env runtime)
  (list
    (list
      (list (symbol "apply")
            (lambda (k f l)
              (apply f (cons k l))))
      (list (symbol "runtime") runtime))
    (list
      (map
        (lambda (nl)
          (list (car nl) (native-to-cps (car nl) (cadr nl))))
        (list
          (list (symbol "*") *)
          (list (symbol "+") +)
          (list (symbol "+") +)
          (list (symbol "-") -)
          (list (symbol "/") /)
          (list (symbol "<") <)
          (list (symbol "<=") <=)
          (list (symbol "=") =)
          (list (symbol ">") >)
          (list (symbol ">=") >=)
          (list (symbol "append") append)
          (list (symbol "assq") assq)
          (list (symbol "boolean?") boolean?)
          (list (symbol "car") car)
          (list (symbol "cdr") cdr)
          (list (symbol "cons") cons)
          (list (symbol "command-line") command-line)
          (list (symbol "eq?") eq?)
          (list (symbol "equal?") equal?)
          (list (symbol "function?") function?)
          (list (symbol "length") length)
          (list (symbol "list") list)
          (list (symbol "list?") list?)
          (list (symbol "make-random-state") make-random-state)
          (list (symbol "modulo") modulo)
          (list (symbol "null?") null?)
          (list (symbol "number?") number?)
          (list (symbol "pair?") pair?)
          (list (symbol "random") random)
          (list (symbol "set-car!") set-car!)
          (list (symbol "set-cdr!") set-cdr!)
          (list (symbol "string") string)
          (list (symbol "string-append") string-append)
          (list (symbol "string-length") string-length)
          (list (symbol "string-list") string-list)
          (list (symbol "string?") string?)
          (list (symbol "symbol") symbol)
          (list (symbol "symbol?") symbol?)
          (list (symbol "sys/exit") sys/exit)
          (list (symbol "sys/read") sys/read)
          (list (symbol "string<?") string<?)
          (list (symbol "sys/write") sys/write)
          (list (symbol "with-input-from-file")
                (lambda (path func)
                  (with-input-from-file
                    path
                    (lambda ()
                      (func (lambda (v) v))))))
          (list (symbol "with-output-to-file")
                (lambda (path func)
                  (with-output-to-file
                    path
                    (lambda ()
                      (func (lambda (v) v))))))
          (list (symbol "run-synchronous-subprocess") run-synchronous-subprocess)
        ))
      #f)))

(define global (make-env runtime))

(define (curryr f . rargs)
  (lambda largs
    (apply f (append largs rargs))))

(define (bind sexpr env)
  (cond
    ((boolean? sexpr) sexpr)
    ((number? sexpr)  sexpr)
    ((string? sexpr)  sexpr)
    ((symbol? sexpr)  (bind-get-coords sexpr env))

    ((not (list? sexpr)) (error "bind: unknown sexpr type" sexpr))

    ((equal? (car sexpr) (symbol "quote"))   sexpr)
    ((equal? (car sexpr) (symbol "apply"))   (bind-pass sexpr env))
    ((equal? (car sexpr) (symbol "if"))      (bind-pass sexpr env))
    ((equal? (car sexpr) (symbol "cond"))    (bind-pass sexpr env))
    ((equal? (car sexpr) (symbol "or"))      (bind-pass sexpr env))
    ((equal? (car sexpr) (symbol "and"))     (bind-pass sexpr env))
    ((equal? (car sexpr) (symbol "call/cc")) (bind-pass sexpr env))
    ((equal? (car sexpr) (symbol "set!"))    (bind-pass sexpr env))
    ((equal? (car sexpr) (symbol "define"))
     (if (list? (second sexpr))
       (let ((named (func-named sexpr))
             (rest (func-rest sexpr)))
         (set-car! env (append (car env) (list (second sexpr))))
         (append (list 'define (second sexpr)) (bind-body env #f named rest (cddr sexpr))))
       (let ((def (bind (third sexpr) env))
             (c (bind-get-coords (second sexpr) env)))
         (if (not (and (equal? (first c) '_ll) (= (second c) 0)))
           (set-car! env (append (car env) (list (second sexpr)))))
         (list 'define c def))))
    ((equal? (car sexpr) (symbol "lambda"))
     (let ((named (lambda-named sexpr))
           (rest (lambda-rest sexpr)))
       (append (list 'lambda (second sexpr))
               (bind-body env #f named rest (cddr sexpr)))))
    ((or (equal? (car sexpr) (symbol "let"))
        (equal? (car sexpr) (symbol "let*")))
     (let* ((self (if (list? (second sexpr)) #f (second sexpr)))
            (argps (if self (third sexpr) (second sexpr)))
            (named (map car argps))
            (body (if self (cdddr sexpr) (cddr sexpr)))
            (argbs
              (let loop ((argps argps) (out (list)))
                (if (null? argps)
                  (reverse out)
                  (loop (cdr argps) (cons (list (caar argps) (bind (cadar argps) (list (map car (reverse out)) env))) out))))))
       (append (list (first sexpr))
               (if self (list self) (list))
               (list argbs)
               (bind-body env self named '() body))))
    (#t (map (curryr bind env) sexpr))))

(define (bind-pass sexpr env)
  (cons (car sexpr) (map (curryr bind env) (cdr sexpr))))

(define (bind-get-coords v env)
  (let loop ((depth 0) (offset 0) (env env))
    (if (not env)
      (list '_lg v)
      (if (null? (car env))
        (loop (+ depth 1) 0 (cadr env))
        (if (equal? (caar env) v)
          (list '_ll depth offset v)
          (loop depth (+ offset 1) (list (cdar env) (cadr env))))))))

(define (bind-body env self named rest body)
  (let* ((senv (list (if self (list self) (list)) env))
         (benv (list (append named (if rest (list rest) (list))) senv)))
    (map (curryr bind benv) body)))

;;; FIXME: more efficient
(define (lglobal) (let loop ((e global))
                      (if (not e)
                        e
                        (list (map car (car e)) (loop (cadr e))))))
(define (repl)
  (let loop ()
    (let ((sexpr (read)))
      (if (eof? sexpr)
        #f
        (let ()
          (eval (bind sexpr (lglobal)) global (lambda (v) v))
          (loop))))))

(define (main)
  (let loop ((std (map (curryr bind (lglobal)) (read-std))))
    (if (null? std)
      #f
      (let ()
        (eval (car std) global (lambda (v) v))
        (loop (cdr std)))))
  (repl))

(main)
