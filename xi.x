;;; EVAL

(define (eval sexpr env)
  (cond ((list? sexpr)    (eval-verb sexpr env))
        ((boolean? sexpr) sexpr)
        ((number? sexpr)  sexpr)
        ((string? sexpr)  sexpr)
        ((symbol? sexpr)  (lookup env sexpr))
        (#t (error "unknown sexpr type" sexpr))))

(define (eval-verb sexpr env)
  (cond ((null? sexpr) sexpr)
        ((equal? (car sexpr) (symbol "define"))  (eval-define sexpr env))
        ((equal? (car sexpr) (symbol "set!"))    (eval-set! sexpr env))
        ((equal? (car sexpr) (symbol "lambda"))  (define-lambda sexpr env))
        ((equal? (car sexpr) (symbol "let"))     (eval-let sexpr env))
        ((equal? (car sexpr) (symbol "let*"))    (eval-let sexpr env))
        ((equal? (car sexpr) (symbol "if"))      (eval-if sexpr env))
        ((equal? (car sexpr) (symbol "cond"))    (eval-cond sexpr env))
        ((equal? (car sexpr) (symbol "or"))      (eval-or sexpr env))
        ((equal? (car sexpr) (symbol "and"))     (eval-and sexpr env))
        (#t                                      (call-func sexpr env))))

(define (eval-define sexpr env)
  (if (list? (second sexpr))
    (define-func sexpr env)
    (define-var sexpr env)))

(define (define-var sexpr env)
  (let ((name (second sexpr))
        (val (eval (third sexpr) env)))
    (set-car! env (cons (list name val) (car env)))
    val))

(define (define-func sexpr env)
  (let ((name (caadr sexpr))
        (named (cdadr sexpr))
        (rest #f)
        (body (cddr sexpr)))
    (if (and (> (length named) 1) (equal? (second (reverse named)) (symbol ".")))
      (let ()
        (set! rest (first (reverse named)))
        (set! named (reverse (cddr (reverse named))))))
    (define f (define-body env #f named rest body))
    (set-car! env (cons (list name f) (car env)))
    f))

(define (define-lambda sexpr env)
  (let* ((args (second sexpr))
         (named (if (list? args) args (list)))
         (rest (if (list? args) #f args))
         (body (cddr sexpr)))
    (if (and (> (length named) 1) (equal? (second (reverse named)) (symbol ".")))
      (let ()
        (set! rest (first (reverse named)))
        (set! named (reverse (cddr (reverse named))))))
    (define-body env #f named rest body)))

(define (eval-let sexpr env)
  (let* ((let-name (if (list? (second sexpr)) #f (second sexpr)))
         (arg-clause (find list? sexpr))
         (argnames (map (lambda (p) (car p)) arg-clause))
         (body (if let-name (cdddr sexpr) (cddr sexpr))))
    (let ((f (define-body env let-name argnames #f body)))
      (let arg-loop ((exprs arg-clause)
                     (vals (list)))
        (if (null? exprs)
          (apply f (reverse vals))
          (let* ((arg-env (list (zip argnames (reverse vals)) env))
                 (val (eval (cadar exprs) arg-env)))
            (arg-loop (cdr exprs) (cons val vals))))))))

(define (define-body env self named rest body)
  (let ((env (list (list) env)))
    (define (f . args)
      (let ((env (list (bind-args args named rest) env)))
        (let body-loop ((body body) (last #f))
          (if (null? body)
            last
            (body-loop (cdr body)
                       (eval (car body) env))))))
    (if self (set-car! env (list (list self f))))
    f))

(define (bind-args args named rest)
  (append
    (zip named args)
    (if rest
      (list (list rest (sublist args (length named) (length args))))
      (list))))

(define (eval-if sexpr env)
  (let* ((p (cadr sexpr))
         (t (caddr sexpr))
         (f (if (> (length sexpr) 3) (cadddr sexpr) #f))
         (pv (eval p env)))
    (eval (if pv t f) env)))

(define (eval-cond sexpr env)
  (let loop ((conds (cdr sexpr)))
    (if (null? conds)
      #f
      (if (eval (caar conds) env)
        (eval (cadar conds) env)
        (loop (cdr conds))))))

(define (eval-or sexpr env)
  (let loop ((clauses (cdr sexpr)))
    (cond ((null? clauses) #f)
          ((eval (car clauses) env) #t)
          (#t (loop (cdr clauses))))))

(define (eval-and sexpr env)
  (let loop ((clauses (cdr sexpr)))
    (cond ((null? clauses) #t)
          ((not (eval (car clauses) env)) #f)
          (#t (loop (cdr clauses))))))

(define (eval-set! sexpr env)
  (let ((name (cadr sexpr))
        (val (eval (caddr sexpr) env)))
    (let loop ((env env))
      (if (not env)
        (error "set: undefined: " name))
      (let ((p (find (lambda (p) (equal? (car p) name)) (car env))))
       (if p
         (set-cdr! p (list val))
         (loop (cadr env)))))))

(define (call-func sexpr env)
  (let ((f (eval (car sexpr) env))
        (args (map (lambda (s) (eval s env)) (cdr sexpr))))
      (apply f args)))

(define (lookup env name)
  (let ((defs (car env))
        (parent (cadr env)))
    (let ((d (assq name defs)))
      (if d
        (cadr d)
        (if parent (lookup parent name) (error "undefined" runtime name))))))

;;; REPL

;;; FIXME! ; why can't I redefined runtime??
(set! runtime (string-append runtime "i"))

(define (make-env runtime)
  (list
    (list
      (list (symbol "*") *)
      (list (symbol "+") +)
      (list (symbol "+") +)
      (list (symbol "-") -)
      (list (symbol "/") /)
      (list (symbol "<") <)
      (list (symbol "<=") <=)
      (list (symbol "=") =)
      (list (symbol ">") >)
      (list (symbol ">=") >=)
      (list (symbol "append") append)
      (list (symbol "apply") apply)
      (list (symbol "assq") assq)
      (list (symbol "boolean?") boolean?)
      (list (symbol "car") car)
      (list (symbol "cdr") cdr)
      (list (symbol "cons") cons)
      (list (symbol "command-line") command-line)
      (list (symbol "eq?") eq?)
      (list (symbol "equal?") equal?)
      (list (symbol "function?") function?)
      (list (symbol "length") length)
      (list (symbol "list") list)
      (list (symbol "list?") list?)
      (list (symbol "modulo") modulo)
      (list (symbol "null?") null?)
      (list (symbol "number?") number?)
      (list (symbol "pair?") pair?)
      (list (symbol "runtime") runtime)
      (list (symbol "set-car!") set-car!)
      (list (symbol "set-cdr!") set-cdr!)
      (list (symbol "string") string)
      (list (symbol "string-append") string-append)
      (list (symbol "string-length") string-length)
      (list (symbol "string-list") string-list)
      (list (symbol "string?") string?)
      (list (symbol "symbol") symbol)
      (list (symbol "symbol?") symbol?)
      (list (symbol "sys/exit") sys/exit)
      (list (symbol "sys/read") sys/read)
      (list (symbol "sys/write") sys/write)
      (list (symbol "with-input-from-file") with-input-from-file)
      (list (symbol "with-output-to-file") with-output-to-file)
      (list (symbol "run-synchronous-subprocess") run-synchronous-subprocess)
    )
    #f))

(define global (make-env runtime))

(define (repl)
  (let loop ()
    (let ((sexpr (read)))
      (if (eof? sexpr)
        #f
        (let ()
          (eval sexpr global)
          (loop))))))

(define (main)
  (let loop ((std (read-std)))
    (if (null? std)
      #f
      (let ()
        (eval (car std) global)
        (loop (cdr std)))))
  (repl))

(main)
