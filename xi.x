;;; EVAL

(define bounce-marker (lambda () #f))

(define (bounce? v)
  (and (pair? v) (equal? bounce-marker (car v))))

(define (make-bounce f args)
  (list
    bounce-marker
    (lambda ()
      (apply f args))))

(define (bounce v)
  ((cadr v)))

(define (trampoline v)
  (if (bounce? v)
    (trampoline (bounce v))
    v))

(define (eval sexpr env tail?)
  (let ((v (eval-inner sexpr env tail?)))
    (if tail?
      v
      (trampoline v))))

(define (eval-inner sexpr env tail?)
  (cond ((list? sexpr)    (eval-verb sexpr env tail?))
        ((boolean? sexpr) sexpr)
        ((number? sexpr)  sexpr)
        ((string? sexpr)  sexpr)
        ((symbol? sexpr)  (lookup env sexpr))
        (#t (error "unknown sexpr type" sexpr))))

(define (eval-verb sexpr env tail?)
  (cond ((null? sexpr) sexpr)
        ((equal? (car sexpr) (symbol "define"))  (eval-define sexpr env))
        ((equal? (car sexpr) (symbol "set!"))    (eval-set! sexpr env))
        ((equal? (car sexpr) (symbol "lambda"))  (define-lambda sexpr env))
        ((equal? (car sexpr) (symbol "let"))     (eval-let sexpr env))
        ((equal? (car sexpr) (symbol "let*"))    (eval-let sexpr env))
        ((equal? (car sexpr) (symbol "if"))      (eval-if sexpr env))
        ((equal? (car sexpr) (symbol "cond"))    (eval-cond sexpr env))
        ((equal? (car sexpr) (symbol "or"))      (eval-or sexpr env))
        ((equal? (car sexpr) (symbol "and"))     (eval-and sexpr env))
        (#t                                      (call-func sexpr env tail?))))

(define (eval-define sexpr env)
  (if (list? (second sexpr))
    (define-func sexpr env)
    (define-var sexpr env)))

(define (define-var sexpr env)
  (let ((name (string (second sexpr)))
        (val (eval (third sexpr) env #f)))
    (set-car! env (cons (list name val) (car env)))
    val))

(define (define-func sexpr env)
  (let ((name (string (caadr sexpr)))
        (named (map string (cdadr sexpr)))
        (rest #f)
        (body (cddr sexpr)))
    (if (and (> (length named) 1) (equal? (second (reverse named)) "."))
      (let ()
        (set! rest (first (reverse named)))
        (set! named (reverse (cddr (reverse named))))))
    (define f (define-body env #f named rest body))
    (set-car! env (cons (list name f) (car env)))
    f))

(define (define-lambda sexpr env)
  (let* ((args (second sexpr))
         (named (map string (if (list? args) args (list))))
         (rest (if (list? args) #f (string args)))
         (body (cddr sexpr)))
    (if (and (> (length named) 1) (equal? (second (reverse named)) "."))
      (let ()
        (set! rest (first (reverse named)))
        (set! named (reverse (cddr (reverse named))))))
    (define-body env #f named rest body)))

(define (eval-let sexpr env)
  (let* ((let-name (if (list? (second sexpr)) #f (string (second sexpr))))
         (arg-clause (find list? sexpr))
         (argnames (map (lambda (p) (string (car p))) arg-clause))
         (body (if let-name (cdddr sexpr) (cddr sexpr))))
    (let ((f (define-body env let-name argnames #f body)))
      (let arg-loop ((exprs arg-clause)
                     (vals (list)))
        (if (null? exprs)
          (apply f (reverse vals))
          (let* ((arg-env (list (zip argnames (reverse vals)) env))
                 (val (eval (cadar exprs) arg-env #f)))
            (arg-loop (cdr exprs) (cons val vals))))))))

(define (define-body env self named rest body)
  (let ((env (list (list) env)))
    (define (f . args)
      (let ((env (list (bind-args args named rest) env)))
        (let body-loop ((body body) (last #f))
          (if (null? body)
            last
            (body-loop (cdr body)
                       (eval (car body) env (null? (cdr body))))))))
    (if self (set-car! env (list (list self f))))
    f))

(define (bind-args args named rest)
  (append
    (zip (map string named) args)
    (if rest
      (list (list (string rest) (sublist args (length named) (length args))))
      (list))))

(define (eval-if sexpr env)
  (let* ((p (cadr sexpr))
         (t (caddr sexpr))
         (f (if (> (length sexpr) 3) (cadddr sexpr) #f))
         (pv (eval p env #f)))
    (eval (if pv t f) env #t)))

(define (eval-cond sexpr env)
  (let loop ((conds (cdr sexpr)))
    (if (null? conds)
      #f
      (if (eval (caar conds) env #f)
        (eval (cadar conds) env #t)
        (loop (cdr conds))))))

(define (eval-or sexpr env)
  (let loop ((clauses (cdr sexpr)))
    (cond ((null? clauses) #f)
          ((eval (car clauses) env #f) #t)
          (#t (loop (cdr clauses))))))

(define (eval-and sexpr env)
  (let loop ((clauses (cdr sexpr)))
    (cond ((null? clauses) #t)
          ((not (eval (car clauses) env #f)) #f)
          (#t (loop (cdr clauses))))))

(define (eval-set! sexpr env)
  (let ((name (string (cadr sexpr)))
        (val (eval (caddr sexpr) env #f)))
    (let loop ((env env))
      (if (not env)
        (error "set: undefined: " name))
      (let ((p (find (lambda (p) (equal? (car p) name)) (car env))))
       (if p
         (set-cdr! p (list val))
         (loop (cadr env)))))))

(define (call-func sexpr env tail?)
  (let ((f (eval (car sexpr) env #f))
        (args (map (lambda (s) (eval s env #f)) (cdr sexpr))))
    (if tail?
      (let ()
        (make-bounce f args))
      (apply f args))))

(define (lookup env sexpr)
  (let ((name (string sexpr))
        (defs (car env))
        (parent (cadr env)))
    (let ((d (find (lambda (d) (equal? (car d) name)) defs)))
      (if d
        (cadr d)
        (if parent (lookup parent name) (error "undefined" runtime name))))))

;;; REPL

;;; FIXME! ; why can't I redefined runtime??
(set! runtime (string-append runtime "i"))

(define (make-env runtime)
  (list
    (list
      (list "*" *)
      (list "+" +)
      (list "+" +)
      (list "-" -)
      (list "/" /)
      (list "<" <)
      (list "<=" <=)
      (list "=" =)
      (list ">" >)
      (list ">=" >=)
      (list "append" append)
      (list "apply" apply)
      (list "boolean?" boolean?)
      (list "car" car)
      (list "cdr" cdr)
      (list "cons" cons)
      (list "equal?" equal?)
      (list "function?" function?)
      (list "length" length)
      (list "list" list)
      (list "list?" list?)
      (list "modulo" modulo)
      (list "null?" null?)
      (list "number?" number?)
      (list "pair?" pair?)
      (list "runtime" runtime)
      (list "set-car!" set-car!)
      (list "set-cdr!" set-cdr!)
      (list "string" string)
      (list "string-append" string-append)
      (list "string-length" string-length)
      (list "string-list" string-list)
      (list "string?" string?)
      (list "symbol" symbol)
      (list "symbol?" symbol?)
      (list "sys/exit" sys/exit)
      (list "sys/read" sys/read)
      (list "sys/write" sys/write)
      (list "with-input-from-file" with-input-from-file)
      (list "with-output-to-file" with-output-to-file)
      (list "run-synchronous-subprocess" run-synchronous-subprocess)
    )
    #f))

(define global (make-env runtime))

(define (repl)
  (let loop ()
    (let ((sexpr (read)))
      (if (eof? sexpr)
        #f
        (let ()
          (eval sexpr global #f)
          (loop))))))

(define (main)
  (with-input-from-file "std.x"
    (lambda ()
      (define sexprs
        (let loop ((out (list)))
          (let ((sexpr (read)))
            (if (eof? sexpr)
              (reverse out)
              (loop (cons sexpr out))))))
      (let loop ((sexprs sexprs))
        (if (null? sexprs)
          #f
          (let ()
            (eval (car sexprs) global #f)
            (loop (cdr sexprs)))))))
  (repl))

(main)
