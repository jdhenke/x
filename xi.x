;;; EVAL -- returns (lambda (env k) ...)

(define (eval sexpr)
  (cond ((list? sexpr)    (eval-verb sexpr))
        ((boolean? sexpr) (lambda (env k) (k sexpr)))
        ((number? sexpr)  (lambda (env k) (k sexpr)))
        ((string? sexpr)  (lambda (env k) (k sexpr)))
        ((vector? sexpr)  (lambda (env k) (k sexpr)))
        ((symbol? sexpr)  (error "eval: unexpected symbol:" sexpr))
        (#t (error "unknown sexpr type" sexpr))))

(define (eval-verb sexpr)
  (cond ((null? sexpr) sexpr)
        ((or (equal? (car sexpr) '_ll)
             (equal? (car sexpr) '_lg))          (eval-lookup sexpr))
        ((equal? (car sexpr) (symbol "define"))  (eval-define sexpr))
        ((equal? (car sexpr) (symbol "set!"))    (eval-set! sexpr))
        ((equal? (car sexpr) (symbol "lambda"))  (eval-lambda sexpr))
        ((equal? (car sexpr) (symbol "apply"))   (eval-apply sexpr))
        ((equal? (car sexpr) (symbol "let"))     (eval-let sexpr))
        ((equal? (car sexpr) (symbol "let*"))    (eval-let sexpr))
        ((equal? (car sexpr) (symbol "if"))      (eval-if sexpr))
        ((equal? (car sexpr) (symbol "cond"))    (eval-cond sexpr))
        ((equal? (car sexpr) (symbol "or"))      (eval-or sexpr))
        ((equal? (car sexpr) (symbol "and"))     (eval-and sexpr))
        ((equal? (car sexpr) (symbol "quote"))   (eval-quote sexpr))
        ((equal? (car sexpr) (symbol "call/cc")) (eval-call/cc sexpr))
        (#t                                      (eval-call-func sexpr))))

(define (eval-define sexpr)
  (let ((s (car (second sexpr))))
    (if (or (equal? s '_ll) (equal? s '_lg))
      (define-var sexpr)
      (define-func sexpr))))

(define (define-var sexpr)
  (let ((c (second sexpr)))
    (if (and (equal? (first c) '_ll) (= (second c) 0))
      (eval-set! sexpr)
      (let ((name (if (equal? (first c) '_ll) (fourth c) (second c))))
        (let ((val-thunk (eval (third sexpr))))
          (lambda (env k)
            (val-thunk env (lambda (val)
              (frame-define! env name val)
              (k val)))))))))

(define (define-func sexpr)
  (let ((name (caadr sexpr))
        (named (cdadr sexpr))
        (rest #f)
        (body (cddr sexpr)))
    (if (and (> (length named) 1) (equal? (second (reverse named)) (symbol ".")))
      (let ()
        (set! rest (first (reverse named)))
        (set! named (reverse (cddr (reverse named))))))
    (define body-thunk (eval-body #f named rest body))
    (lambda (env k)
      (body-thunk env (lambda (f)
        (frame-define! env name f)
        (k f))))))
      

(define (eval-set! sexpr)
  (let ((c (cadr sexpr))
        (val-thunk (eval (caddr sexpr))))
      (lambda (env k)
        (val-thunk env (lambda (val)
            (if (equal? (first c) '_lg)
              (set! c (bind-get-coords (second c) (lex-env env))))
            (let loop ((env env) (depth 0))
              (if (not env)
                (error "xi: not present" c sexpr))
              (if (= depth (cadr c))
                (let ((p (vector-ref (car env) (caddr c))))
                  (set-cdr! p (list val))
                  (k val))
                (loop (cadr env) (+ depth 1)))))))))

(define (eval-lambda sexpr)
  (let* ((args (second sexpr))
         (named (if (list? args) args (list)))
         (rest (if (list? args) #f args))
         (body (cddr sexpr)))
    (if (and (> (length named) 1) (equal? (second (reverse named)) (symbol ".")))
      (let ()
        (set! rest (first (reverse named)))
        (set! named (reverse (cddr (reverse named))))))
      (eval-body #f named rest body)))

(define (eval-apply sexpr)
  (let ((f-thunk (eval (cadr sexpr)))
        (l-thunk (eval (caddr sexpr))))
      (lambda (env k)
        (f-thunk env (lambda (f)
          (l-thunk env (lambda (l)
            (apply f (cons k l)))))))))

(define (eval-let sexpr)
  (let* ((let-name (if (list? (second sexpr)) #f (second sexpr)))
         (arg-clause (find list? sexpr))
         (argnames (map (lambda (p) (car p)) arg-clause))
         (body (if let-name (cdddr sexpr) (cddr sexpr)))
         (arg-thunks (map (lambda (p) (eval (cadr p))) arg-clause))
         (body-thunks (map eval body))
         (f-thunk (eval-body let-name argnames #f body)))
    (lambda (env k)
      (let arg-loop ((args arg-thunks)
                      (vals (list)))
        (if (null? args)
          (f-thunk env (lambda (f)
            (apply f (cons k (reverse vals)))))
          ((car args)
            (list (list->vector (zip argnames (reverse vals))) env)
            (lambda (val)
              (arg-loop (cdr args) (cons val vals)))))))))

(define (eval-body self named rest body)
  (define num-args (+ (length named) (if rest 1 0)))
  (define num-defs
    (length (filter (lambda (s) (and (list? s) (not (null? s)) (equal? (car s) 'define))) body)))
  (define frame-size (+ num-args num-defs))
  (let ((thunks (map eval body)))
    (lambda (env k)
      (let ((env (list (make-vector 0 #f) env)))
        (define (f k . args)
          (let ((env (list (bind-args args named rest frame-size) env (list num-args))))
            (let loop ((thunks thunks))
              (cond ((null? thunks) (k #f))
                    ((null? (cdr thunks)) ((car thunks) env k))
                    (#t ((car thunks) env (lambda (v) (loop (cdr thunks)))))))))
        (if self (set-car! env (list->vector (list (list self f)))))
        (k f)))))

(define (bind-args args named rest frame-size)
  (let ((v (make-vector frame-size (list #f #f)))
        (nnamed (length named)))
    (let loop ((i 0) (ns named) (as args))
      (if (not (null? ns))
        (let ()
          (vector-set! v i (list (car ns) (car as)))
          (loop (+ i 1) (cdr ns) (cdr as)))))
    (if rest
      (vector-set! v nnamed (list rest (sublist args nnamed (length args)))))
    v))

(define (frame-define! env name val)
  (if (and (not (null? (cddr env))) (caddr env))
    (let ((cursor (caddr env)))
      (vector-set! (car env) (car cursor) (list name val))
      (set-car! cursor (+ (car cursor) 1)))
    (set-car! env (vector-append (car env) (list name val)))))

(define (eval-if sexpr)
  (let ((p-thunk (eval (cadr sexpr)))
        (t-thunk (eval (caddr sexpr)))
        (f-thunk (eval (if (> (length sexpr) 3) (cadddr sexpr) #f))))
    (lambda (env k)
      (p-thunk env (lambda (pv)
        (if pv
          (t-thunk env k)
          (f-thunk env k)))))))

(define (eval-cond sexpr)
  (let ((cond-thunks (map (lambda (c) (map eval c)) (cdr sexpr))))
    (lambda (env k)
      (let loop ((cond-thunks cond-thunks))
        (if (null? cond-thunks)
          (k #f)
          ((caar cond-thunks) env (lambda (cv)
            (if cv
              ((cadar cond-thunks) env k)
              (loop (cdr cond-thunks))))))))))

(define (eval-or sexpr)
  (let ((clause-thunks (map eval (cdr sexpr))))
    (lambda (env k)
      (let loop ((clause-thunks clause-thunks))
        (cond ((null? clause-thunks) (k #f))
              (#t ((car clause-thunks) env
                        (lambda (cv)
                          (if cv
                            (k #t)
                            (loop (cdr clause-thunks)))))))))))

(define (eval-and sexpr)
  (let ((clause-thunks (map eval (cdr sexpr))))
    (lambda (env k)
      (let loop ((clause-thunks clause-thunks))
        (cond ((null? clause-thunks) (k #t))
              (#t ((car clause-thunks) env
                        (lambda (cv)
                          (if cv
                            (loop (cdr clause-thunks))
                            (k #f))))))))))

(define (eval-call-func sexpr)
  (let ((f-thunk (eval (car sexpr)))
        (arg-thunks (map eval (cdr sexpr))))
      (lambda (env k)
        (f-thunk env (lambda (f)
          (let loop ((arg-thunks arg-thunks) (arg-vals (list)))
            (if (null? arg-thunks)
              (apply f (cons k (reverse arg-vals)))
              ((car arg-thunks) env (lambda (argv) (loop (cdr arg-thunks) (cons argv arg-vals)))))))))))

(define (eval-call/cc sexpr)
  (let ((thunk (eval (cadr sexpr))))
    (lambda (env k)
      (thunk env (lambda (f)
        (f k (lambda (k2 val) (k val))))))))

(define (eval-quote sexpr)
  (lambda (env k)
    (k (cadr sexpr))))

(define (eval-lookup c)
  (if (equal? (car c) '_ll)
    (let ((depth (cadr c))
          (offset (caddr c)))
      (lambda (env k)
        (let loop ((d 0) (env env))
          (if (= d depth)
          (let ((p (vector-ref (car env) offset)))
            (k (cadr p)))
          (loop (+ d 1) (cadr env))))))
    (let ()
      (define (f env k)
        (let ((lc (bind-get-coords (second c) (lex-env env))))
          (set! f (eval-lookup lc))
          (f env k)))
      (lambda (env k)
        (f env k)))))

;;; REPL

;;; FIXME! ; why can't I redefined runtime??
(set! runtime (string-append runtime "i"))

(define (native-to-cps n f)
  (lambda (k . args)
    (k (apply f args))))

(define (make-env runtime)
  (list
    (list->vector
      (list
        (list (symbol "apply")
              (lambda (k f l)
                (apply f (cons k l))))
        (list (symbol "runtime") runtime)))
    (list
      (list->vector
        (map
          (lambda (nl)
            (list (car nl) (native-to-cps (car nl) (cadr nl))))
          (list
          (list (symbol "*") *)
          (list (symbol "+") +)
          (list (symbol "-") -)
          (list (symbol "/") /)
          (list (symbol "<") <)
          (list (symbol "<=") <=)
          (list (symbol "=") =)
          (list (symbol ">") >)
          (list (symbol ">=") >=)
          (list (symbol "append") append)
          (list (symbol "assq") assq)
          (list (symbol "boolean?") boolean?)
          (list (symbol "car") car)
          (list (symbol "cdr") cdr)
          (list (symbol "command-line") command-line)
          (list (symbol "cons") cons)
          (list (symbol "eq?") eq?)
          (list (symbol "equal?") equal?)
          (list (symbol "function?") function?)
          (list (symbol "length") length)
          (list (symbol "list") list)
          (list (symbol "list->vector") list->vector)
          (list (symbol "list?") list?)
          (list (symbol "make-random-state") make-random-state)
          (list (symbol "make-vector") make-vector)
          (list (symbol "modulo") modulo)
          (list (symbol "null?") null?)
          (list (symbol "number?") number?)
          (list (symbol "random") random)
          (list (symbol "run-synchronous-subprocess") run-synchronous-subprocess)
          (list (symbol "set-car!") set-car!)
          (list (symbol "set-cdr!") set-cdr!)
          (list (symbol "string") string)
          (list (symbol "string-append") string-append)
          (list (symbol "string-length") string-length)
          (list (symbol "string-list") string-list)
          (list (symbol "string<?") string<?)
          (list (symbol "string?") string?)
          (list (symbol "substring") substring)
          (list (symbol "symbol") symbol)
          (list (symbol "symbol?") symbol?)
          (list (symbol "sys/close") sys/close)
          (list (symbol "sys/dup") sys/dup)
          (list (symbol "sys/dup2") sys/dup2)
          (list (symbol "sys/execve") sys/execve)
          (list (symbol "sys/exit") sys/exit)
          (list (symbol "sys/fork") sys/fork)
          (list (symbol "sys/open") sys/open)
          (list (symbol "sys/read") sys/read)
          (list (symbol "sys/wait") sys/wait)
          (list (symbol "sys/write") sys/write)
          (list (symbol "vector->list") vector->list)
          (list (symbol "vector-length") vector-length)
          (list (symbol "vector-ref") vector-ref)
          (list (symbol "vector-set!") vector-set!)
          (list (symbol "vector?") vector?)
          (list (symbol "with-input-from-file")
                (lambda (path func)
                  (with-input-from-file
                    path
                    (lambda ()
                      (func (lambda (v) v))))))
          (list (symbol "with-output-to-file")
                (lambda (path func)
                  (with-output-to-file
                    path
                    (lambda ()
                      (func (lambda (v) v))))))
        )))
      #f)))

(define global (make-env runtime))

(define (curryr f . rargs)
  (lambda largs
    (apply f (append largs rargs))))

(define (bind sexpr env)
  (cond
    ((boolean? sexpr) sexpr)
    ((number? sexpr)  sexpr)
    ((string? sexpr)  sexpr)
    ((vector? sexpr)  sexpr)
    ((symbol? sexpr)  (bind-get-coords sexpr env))

    ((not (list? sexpr)) (error "bind: unknown sexpr type" sexpr))

    ((equal? (car sexpr) (symbol "quote"))   sexpr)
    ((equal? (car sexpr) (symbol "apply"))   (bind-pass sexpr env))
    ((equal? (car sexpr) (symbol "if"))      (bind-pass sexpr env))
    ((equal? (car sexpr) (symbol "cond"))    (bind-pass sexpr env))
    ((equal? (car sexpr) (symbol "or"))      (bind-pass sexpr env))
    ((equal? (car sexpr) (symbol "and"))     (bind-pass sexpr env))
    ((equal? (car sexpr) (symbol "call/cc")) (bind-pass sexpr env))
    ((equal? (car sexpr) (symbol "set!"))    (bind-pass sexpr env))
    ((equal? (car sexpr) (symbol "define"))
     (if (list? (second sexpr))
       (let ((named (func-named sexpr))
             (rest (func-rest sexpr)))
         (set-car! env (append (car env) (list (second sexpr))))
         (append (list 'define (second sexpr)) (bind-body env #f named rest (cddr sexpr))))
       (let ((def (bind (third sexpr) env))
             (c (bind-get-coords (second sexpr) env)))
         (if (not (and (equal? (first c) '_ll) (= (second c) 0)))
           (set-car! env (append (car env) (list (second sexpr)))))
         (list 'define c def))))
    ((equal? (car sexpr) (symbol "lambda"))
     (let ((named (lambda-named sexpr))
           (rest (lambda-rest sexpr)))
       (append (list 'lambda (second sexpr))
               (bind-body env #f named rest (cddr sexpr)))))
    ((or (equal? (car sexpr) (symbol "let"))
        (equal? (car sexpr) (symbol "let*")))
     (let* ((self (if (list? (second sexpr)) #f (second sexpr)))
            (argps (if self (third sexpr) (second sexpr)))
            (named (map car argps))
            (body (if self (cdddr sexpr) (cddr sexpr)))
            (argbs
              (let loop ((argps argps) (out (list)))
                (if (null? argps)
                  (reverse out)
                  (loop (cdr argps) (cons (list (caar argps) (bind (cadar argps) (list (map car (reverse out)) env))) out))))))
       (append (list (first sexpr))
               (if self (list self) (list))
               (list argbs)
               (bind-body env self named #f body))))
    (#t (map (curryr bind env) sexpr))))

(define (bind-pass sexpr env)
  (cons (car sexpr) (map (curryr bind env) (cdr sexpr))))

(define (bind-get-coords v env)
  (let loop ((depth 0) (offset 0) (env env))
    (if (not env)
      (list '_lg v)
      (if (null? (car env))
        (loop (+ depth 1) 0 (cadr env))
        (if (equal? (caar env) v)
          (list '_ll depth offset v)
          (loop depth (+ offset 1) (list (cdr (car env)) (cadr env))))))))

(define (bind-body env self named rest body)
  (let* ((senv (list (if self (list self) (list)) env))
         (benv (list (append named (if rest (list rest) (list))) senv)))
    (map (curryr bind benv) body)))

(define (lglobal) (lex-env global))

(define (lex-env env)
  (let loop ((e env))
    (if (not e)
      e
      (list (map car (vector->list (car e))) (loop (cadr e))))))

(define (repl)
  (let loop ()
    (let ((sexpr (read)))
      (if (eof? sexpr)
        #f
        (let ()
          ((eval (bind sexpr (lglobal))) global (lambda (v) v))
          (loop))))))

(define (main)
  (let loop ((std (map (curryr bind (lglobal)) (read-std))))
    (if (null? std)
      #f
      (let ()
        ((eval (car std)) global (lambda (v) v))
        (loop (cdr std)))))
  (repl))

(main)
